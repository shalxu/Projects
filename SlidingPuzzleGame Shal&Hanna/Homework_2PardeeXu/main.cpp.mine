//
//  main.cpp
//  Homework_2PardeeXu
//
//  Created by Hanna on 2/9/15.
//  Copyright (c) 2015 University of Denver. All rights reserved.
//

#include <iostream>
#include "SlidingPuzzleState.h"

void DepthLimitedDFS(int depth, SlidingPuzzleState *state) {
      state->Print();
    std::cout<<std::endl;
    if (depth == 0 ||state->IsSolution())
    {
        return;
    }
    LList<int> *moveList= new LList<int>();
    *moveList =  state->GetMoves();
    int move=-1;
    while(moveList->IsEmpty() == false){
        
        move=moveList->PeekFront();
        std::cout<<"m"<<move;
        std::cout<<std::endl;
        moveList->RemoveFront();
        state->ApplyMove(move);
        DepthLimitedDFS(depth -1, state);
        state->UndoMove(move);
        
    }
}

int main(int argc, const char * argv[]) {
    //Your code should check that all tile values are in the range [0..11] and that there are no duplicates (in case of error, write a message to std::cerr).
    const int exampleTiles[12] = { 0, 5, 3, 7, 6, 1, 2, 11, 4, 8, 9, 10 };
    SlidingPuzzleState *puzzleState = new SlidingPuzzleState(exampleTiles);
    puzzleState->Print();
	std::cout<<puzzleState->ApplyMove(1);
	puzzleState->UndoMove(1);
	puzzleState->Print();
	//LList<int> *moveList = new LList<int>(); 
	//*moveList=puzzleState->GetMoves();
	/*while (moveList->IsEmpty() == false)
	//{
		std::cout << moveList->PeekFront();
		std::cout << "?";
		moveList->RemoveFront();
	//}
	*/
    //DepthLimitedDFS(1, puzzleState);

         return 0;
}

